// this router is mapped in the index.ts ( app router)
// this is a totally seperate end point
import { AuthCredentialsValidator } from "../lib/validators/account-credentials-validator";
import { publicProcedure, router } from "./trpc";
import { getPayloadClient } from "../get-payload";
import { TRPCError } from "@trpc/server";
import { z } from "zod";

export const authRouter = router({
  createPayloadUser: publicProcedure
    .input(AuthCredentialsValidator)
    .mutation(async ({ input }) => {
      // here the input comes from the '.input' and it is destructured  as the email and the password
      const { email, password } = input;
      const payload = await getPayloadClient();

      // check if user already exists
      // here the "payload.something" that we getting from get-payload and we are getting this from the payload type
      // here the find comes from the 'paginated' and docs property exist there from the
      // 'find','docs' are the property of the payload and equals is a query 'see the docs'
      // here the docs array is given a custom name called users;
      const { docs: users } = await payload.find({
        collection: "users",
        where: {
          email: {
            equals: email,
          },
        },
      });

      // check: if the above operation found a user then give a status code of conflict.
      if (users.length !== 0) throw new TRPCError({ code: "CONFLICT" });

      // if no users are found then create a new payload using the email and passoword that we get from the input
      // aslo assign the role to the user
      // this is a custom collection so
      await payload.create({
        collection: "users",
        data: {
          email,
          password,
          role: "user",
        },
      });

      // this return statement is foor the trpc; as this is the backend ;
      // success:true helps the trpc client to understand that the backend is working
      return { success: true, sentToEmail: email };
    }),

  // this is the backend to verify email;
  // go to the page.tsx in verify email; it links to the verify email component
  // this verify email component uses this backend
  // Now this verify email end point is accessable to the client side code; by using the  trpc.auth.verifyEmail
  verifyEmail: publicProcedure
    .input(z.object({ token: z.string() }))
    .query(async ({ input }) => {
      //query similar to the get; it gets the token which is the input ;
      const { token } = input;

      const payload = await getPayloadClient();

      // note: a uniquen token is created by the payload client and the is verified thing in the database is also made by the apyload client.
      // this verifyEmail comes from the payload; internal property
      //
      // the isVerified tells that the token that is generated by the payload is verified usinging the verifyEmail provided by the payloadS
      // here the paylaod automatically gets the things from the database of the formed for the users
      const isVerified = await payload.verifyEmail({
        collection: "users",
        token,
      });

      if (!isVerified) throw new TRPCError({ code: "UNAUTHORIZED" });

      return { success: true };
    }),

  signIn: publicProcedure
    .input(AuthCredentialsValidator)
    .mutation(async ({ input, ctx }) => {
      const { email, password } = input;
      const { res } = ctx;

      const payload = await getPayloadClient();

      try {
        // the cms provides the log in method; no need to manually check if the user exist or not in the database
        //the res context is actually comming from the server; the payload checks if there is a user and then email and the password to the server(express);
        // then after the express server gives a cookie(token) as a response and saved as a cookie
        // check in the inspect; then the cookie is treansferred to the client using the trpc context;
        await payload.login({
          collection: "users",
          data: {
            email,
            password,
          },
          res,
        });

        return { success: true };
      } catch (err) {
        throw new TRPCError({ code: "UNAUTHORIZED" });
      }
    }),
});
